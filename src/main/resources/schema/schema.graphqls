scalar Date

input OrganisationInput {
    name: String!
}

input LoginInput {
    email: String!
    password: String!
}

input RegisterInput {
    email: String!
    password: String!
    name: String
}

type Organisation @connection {
    id: String!
    name: String!
    createdBy: String!
}

type Department @connection {
    id: String!
    name: String!
    createdBy: String!
}

type User @connection {
    id: String!
    name: String!
    email: String!
    seniority: String
}

type LoginResponse {
    token: String!
    user: User!
}

type Schedule {
    id: String!
}

enum AvailabilityType {
    DESIRED
    UNDESIRED
    UNAVAILABLE
}

type Availability {
    id: String!
    date: Date!
    type: AvailabilityType!
}

input AvailabilityInput {
    userId: String!
    date: Date!
    type: AvailabilityType!
}

type Query {
    organisations (first: Int, last: Int, after: String): OrganisationConnection
    organisation (id: String!): Organisation
    
    currentUser: User
    login (input: LoginInput!): LoginResponse

    departments (organisationId: String!, first: Int, last: Int, after: String): DepartmentConnection
    department (id: String!): Department

    schedule (id: String!): Schedule

    availabilities (from: Date!, to: Date!): [Availability]
}

type Mutation {
    createOrganisation (input: OrganisationInput!): Organisation
    organisationAddUser (organisationId: String!, email: String!): Organisation

    createDepartment (organisationId: String!, name: String!): Department
    departmentAddUser (departmentId: String!, email: String!): Department
    
    register (input: RegisterInput!): LoginResponse

    startSolving (scheduleId: String!): Boolean
    stopSolving (scheduleId: String!): Boolean

    setAvailability (input: AvailabilityInput!): Availability
}